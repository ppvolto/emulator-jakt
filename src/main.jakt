import vm { RegisterController, Memory, Value, Address }

enum Opcode {
    LB(rd: u64, func3: u64, rs1: u64, imm: Value)
    LH(rd: u64, func3: u64, rs1: u64, imm: Value)
    LW(rd: u64, func3: u64, rs1: u64, imm: Value)
    LBU(rd: u64, func3: u64, rs1: u64, imm: Value)
    LHU(rd: u64, func3: u64, rs1: u64, imm: Value)
    Unspecified(value: Value)
}

enum RegOp {
    Read(rs: u64)
    Write(rd: u64, value: Value)
    Unspecified
}

enum MemoryOp {
    ByteRead(address: Address, rd: u64)
    HalfWordRead(address: Address, rd: u64)
    WordRead(address: Address, rd: u64)
    ByteUnsignedRead(address: Address, rd: u64)
    HalfWordUnsignedRead(address: Address, rd: u64)
    Unspecified
}

enum VMState {
    Fetch(value: Address)
    Decode(value: Value)
    Execute(value: Opcode)
    MemAccess(value: MemoryOp)
    WriteBack(write: bool, rd: u64, value: Value)
}

struct VM {
    address: Address
    programm: Memory
    memory: Memory
    registers: RegisterController,
    state: VMState

    function create() throws -> VM {
        let registers = RegisterController::create();
        let memory_size: usize = 1 * 1024 * 1024;
        let memory = Memory::create(size: memory_size);
        let programm = Memory::create(size: 0);
        let rom_address = Address::from(value: Value::from_u64(value: 0));
        let state = VMState::Fetch(value: rom_address);
        return VM(address: Address::Zero(), programm, memory, registers, state);
    }

    function read_reg(this, register_: u64) throws -> Value {
        return match register_ {
            0 => Value::from_i64(value: 0),
            else => .registers.read_register(index: register_),
        }
    }

    function write_reg(mut this, register_: u64, value: Value) throws {
        if register_ == 0 {
            return
        }
        .registers.write_register(index: register_, value)
    }

    function load_instruction(mut this, value: Address) throws {
        .address = value;
        let address_value = .programm.read(address: value, size: 4);
        .state = VMState::Decode(value: address_value)
    }

    function decode_itype(this, value: Value) throws -> Opcode {
        let rd = ((value.to_u64() >> 7) & 0b11111);
        let rs1 = ((value.to_u64() >> 15) & 0b11111);
        let func3 = (value.to_u64() >> 12) & 0b111;
        let imm = Value::from_i64(value: value.to_i64() >> 20);
        return match func3 {
            0b000 => Opcode::LB(rd, func3, rs1, imm),
            0b001 => Opcode::LH(rd, func3, rs1, imm),
            0b010 => Opcode::LW(rd, func3, rs1, imm),
            0b100 => Opcode::LBU(rd, func3, rs1, imm),
            0b101 => Opcode::LHU(rd, func3, rs1, imm),
            else => Opcode::Unspecified(value)
        }
    }

    function decode(mut this, value: Value) throws {
        let opcode = value.to_i64() & 0b1111111
        let type = match opcode {
            0b11 => .decode_itype(value),
            else => Opcode::Unspecified(value)
        }
        .state = VMState::Execute(value: type)
    }

    function execute(mut this, value: Opcode) throws {
        match value {
            Opcode::LB(rd, func3, rs1, imm)
                | Opcode::LH(rd, func3, rs1, imm)
                | Opcode::LW(rd, func3, rs1, imm)
                | Opcode::LBU(rd, func3, rs1, imm)
                | Opcode::LHU(rd, func3, rs1, imm) => {
                let register_value = .read_reg(register_: rs1).to_i64() + imm.to_i64();
                let address =  Address::from(value: Value::from_i64(value: register_value))
                let result = match value {
                    Opcode::LB => MemoryOp::ByteRead(address, rd)
                    Opcode::LH => MemoryOp::HalfWordRead(address, rd)
                    Opcode::LW => MemoryOp::WordRead(address, rd)
                    Opcode::LBU => MemoryOp::ByteUnsignedRead(address, rd)
                    Opcode::LHU => MemoryOp::HalfWordUnsignedRead(address, rd)
                    else => MemoryOp::Unspecified
                }
                .state = VMState::MemAccess(value: result)
            },
            else => {}
        }
    }

    function memory_access(mut this, value: MemoryOp) throws {
        let size = match value {
            MemoryOp::ByteRead | MemoryOp::ByteUnsignedRead => 8,
            MemoryOp::HalfWordRead | MemoryOp::HalfWordUnsignedRead => 16,
            MemoryOp::WordRead | else => 32
        }
        let address: Address = match value {
            MemoryOp::ByteRead(address) | MemoryOp::ByteUnsignedRead(address)
            | MemoryOp::HalfWordRead(address) | MemoryOp::HalfWordUnsignedRead(address)
            | MemoryOp::WordRead(address) => address
            else => Address::Zero()
        }
        let memory_value = .memory.read(address: address, size: size as! u64);
        match value {
            MemoryOp::ByteRead(rd) | MemoryOp::ByteUnsignedRead(rd)
            | MemoryOp::HalfWordRead(rd) | MemoryOp::HalfWordUnsignedRead(rd)
            | MemoryOp::WordRead(rd) => {
                .state = VMState::WriteBack(write: true, rd, value: memory_value)
            }
            else => {}
        }
    }

    function cylce(mut this) throws {
        match .state {
            Fetch(value) => .load_instruction(value),
            Decode(value) => .decode(value),
            Execute(value) => .execute(value),
            MemAccess(value) => .memory_access(value),
            WriteBack(write, rd, value) => {
                if write {
                    .write_reg(register_: rd, value)
                }
                let next_address = Value::from_u64(value: .address.value.to_u64() + 4)
                .state = VMState::Fetch(value: Address::from(value: next_address))
            }
        }
    }

    function debug(this) {
        println("{:0>4x}:  ", .address.value.to_u32())
        println("reg:   {}", .registers.value);
        println("state: {}", .state);
    }
}

function main(args: [String]) {
    guard args.size() > 1 else {
        println("usage: riscvjact <path/to/file.rom>")
        return 1
    }
    let path = args[0];
    mut vm = VM::create();
    vm.programm.from_file(path)
    print("programm: ")
    vm.programm.debug(print_content: false)
    vm.debug()
    // vm.cylce()
    // vm.cylce()
    // for _ in 0..7 {

    // }
    // vm.cylce()
    // vm.cylce()
    // vm.cylce()
    // vm.cylce()
    // vm.cylce()
}